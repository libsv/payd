// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/libsv/go-bc"
	"github.com/libsv/go-bc/spv"
	"github.com/libsv/go-bt/v2"
)

// Ensure, that PaymentVerifierMock does implement spv.PaymentVerifier.
// If this is not the case, regenerate this file with moq.
var _ spv.PaymentVerifier = &PaymentVerifierMock{}

// PaymentVerifierMock is a mock implementation of spv.PaymentVerifier.
//
// 	func TestSomethingThatUsesPaymentVerifier(t *testing.T) {
//
// 		// make and configure a mocked spv.PaymentVerifier
// 		mockedPaymentVerifier := &PaymentVerifierMock{
// 			VerifyMerkleProofFunc: func(contextMoqParam context.Context, bytes []byte) (*spv.MerkleProofValidation, error) {
// 				panic("mock out the VerifyMerkleProof method")
// 			},
// 			VerifyMerkleProofJSONFunc: func(contextMoqParam context.Context, merkleProof *bc.MerkleProof) (bool, bool, error) {
// 				panic("mock out the VerifyMerkleProofJSON method")
// 			},
// 			VerifyPaymentFunc: func(ctx context.Context, pTx *bt.Tx, ancestors []byte, opts ...spv.VerifyOpt) (*bt.Tx, error) {
// 				panic("mock out the VerifyPayment method")
// 			},
// 		}
//
// 		// use mockedPaymentVerifier in code that requires spv.PaymentVerifier
// 		// and then make assertions.
//
// 	}
type PaymentVerifierMock struct {
	// VerifyMerkleProofFunc mocks the VerifyMerkleProof method.
	VerifyMerkleProofFunc func(contextMoqParam context.Context, bytes []byte) (*spv.MerkleProofValidation, error)

	// VerifyMerkleProofJSONFunc mocks the VerifyMerkleProofJSON method.
	VerifyMerkleProofJSONFunc func(contextMoqParam context.Context, merkleProof *bc.MerkleProof) (bool, bool, error)

	// VerifyPaymentFunc mocks the VerifyPayment method.
	VerifyPaymentFunc func(ctx context.Context, pTx *bt.Tx, ancestors []byte, opts ...spv.VerifyOpt) (*bt.Tx, error)

	// calls tracks calls to the methods.
	calls struct {
		// VerifyMerkleProof holds details about calls to the VerifyMerkleProof method.
		VerifyMerkleProof []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Bytes is the bytes argument value.
			Bytes []byte
		}
		// VerifyMerkleProofJSON holds details about calls to the VerifyMerkleProofJSON method.
		VerifyMerkleProofJSON []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// MerkleProof is the merkleProof argument value.
			MerkleProof *bc.MerkleProof
		}
		// VerifyPayment holds details about calls to the VerifyPayment method.
		VerifyPayment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PTx is the pTx argument value.
			PTx *bt.Tx
			// Ancestors is the ancestors argument value.
			Ancestors []byte
			// Opts is the opts argument value.
			Opts []spv.VerifyOpt
		}
	}
	lockVerifyMerkleProof     sync.RWMutex
	lockVerifyMerkleProofJSON sync.RWMutex
	lockVerifyPayment         sync.RWMutex
}

// VerifyMerkleProof calls VerifyMerkleProofFunc.
func (mock *PaymentVerifierMock) VerifyMerkleProof(contextMoqParam context.Context, bytes []byte) (*spv.MerkleProofValidation, error) {
	if mock.VerifyMerkleProofFunc == nil {
		panic("PaymentVerifierMock.VerifyMerkleProofFunc: method is nil but PaymentVerifier.VerifyMerkleProof was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Bytes           []byte
	}{
		ContextMoqParam: contextMoqParam,
		Bytes:           bytes,
	}
	mock.lockVerifyMerkleProof.Lock()
	mock.calls.VerifyMerkleProof = append(mock.calls.VerifyMerkleProof, callInfo)
	mock.lockVerifyMerkleProof.Unlock()
	return mock.VerifyMerkleProofFunc(contextMoqParam, bytes)
}

// VerifyMerkleProofCalls gets all the calls that were made to VerifyMerkleProof.
// Check the length with:
//     len(mockedPaymentVerifier.VerifyMerkleProofCalls())
func (mock *PaymentVerifierMock) VerifyMerkleProofCalls() []struct {
	ContextMoqParam context.Context
	Bytes           []byte
} {
	var calls []struct {
		ContextMoqParam context.Context
		Bytes           []byte
	}
	mock.lockVerifyMerkleProof.RLock()
	calls = mock.calls.VerifyMerkleProof
	mock.lockVerifyMerkleProof.RUnlock()
	return calls
}

// VerifyMerkleProofJSON calls VerifyMerkleProofJSONFunc.
func (mock *PaymentVerifierMock) VerifyMerkleProofJSON(contextMoqParam context.Context, merkleProof *bc.MerkleProof) (bool, bool, error) {
	if mock.VerifyMerkleProofJSONFunc == nil {
		panic("PaymentVerifierMock.VerifyMerkleProofJSONFunc: method is nil but PaymentVerifier.VerifyMerkleProofJSON was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		MerkleProof     *bc.MerkleProof
	}{
		ContextMoqParam: contextMoqParam,
		MerkleProof:     merkleProof,
	}
	mock.lockVerifyMerkleProofJSON.Lock()
	mock.calls.VerifyMerkleProofJSON = append(mock.calls.VerifyMerkleProofJSON, callInfo)
	mock.lockVerifyMerkleProofJSON.Unlock()
	return mock.VerifyMerkleProofJSONFunc(contextMoqParam, merkleProof)
}

// VerifyMerkleProofJSONCalls gets all the calls that were made to VerifyMerkleProofJSON.
// Check the length with:
//     len(mockedPaymentVerifier.VerifyMerkleProofJSONCalls())
func (mock *PaymentVerifierMock) VerifyMerkleProofJSONCalls() []struct {
	ContextMoqParam context.Context
	MerkleProof     *bc.MerkleProof
} {
	var calls []struct {
		ContextMoqParam context.Context
		MerkleProof     *bc.MerkleProof
	}
	mock.lockVerifyMerkleProofJSON.RLock()
	calls = mock.calls.VerifyMerkleProofJSON
	mock.lockVerifyMerkleProofJSON.RUnlock()
	return calls
}

// VerifyPayment calls VerifyPaymentFunc.
func (mock *PaymentVerifierMock) VerifyPayment(ctx context.Context, pTx *bt.Tx, ancestors []byte, opts ...spv.VerifyOpt) (*bt.Tx, error) {
	if mock.VerifyPaymentFunc == nil {
		panic("PaymentVerifierMock.VerifyPaymentFunc: method is nil but PaymentVerifier.VerifyPayment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		PTx       *bt.Tx
		Ancestors []byte
		Opts      []spv.VerifyOpt
	}{
		Ctx:       ctx,
		PTx:       pTx,
		Ancestors: ancestors,
		Opts:      opts,
	}
	mock.lockVerifyPayment.Lock()
	mock.calls.VerifyPayment = append(mock.calls.VerifyPayment, callInfo)
	mock.lockVerifyPayment.Unlock()
	return mock.VerifyPaymentFunc(ctx, pTx, ancestors, opts...)
}

// VerifyPaymentCalls gets all the calls that were made to VerifyPayment.
// Check the length with:
//     len(mockedPaymentVerifier.VerifyPaymentCalls())
func (mock *PaymentVerifierMock) VerifyPaymentCalls() []struct {
	Ctx       context.Context
	PTx       *bt.Tx
	Ancestors []byte
	Opts      []spv.VerifyOpt
} {
	var calls []struct {
		Ctx       context.Context
		PTx       *bt.Tx
		Ancestors []byte
		Opts      []spv.VerifyOpt
	}
	mock.lockVerifyPayment.RLock()
	calls = mock.calls.VerifyPayment
	mock.lockVerifyPayment.RUnlock()
	return calls
}
