// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-spvchannels"
	"github.com/libsv/payd"
	"sync"
)

// Ensure, that PeerChannelsServiceMock does implement payd.PeerChannelsService.
// If this is not the case, regenerate this file with moq.
var _ payd.PeerChannelsService = &PeerChannelsServiceMock{}

// PeerChannelsServiceMock is a mock implementation of payd.PeerChannelsService.
//
// 	func TestSomethingThatUsesPeerChannelsService(t *testing.T) {
//
// 		// make and configure a mocked payd.PeerChannelsService
// 		mockedPeerChannelsService := &PeerChannelsServiceMock{
// 			ActiveProofChannelsFunc: func(ctx context.Context) ([]payd.PeerChannel, error) {
// 				panic("mock out the ActiveProofChannels method")
// 			},
// 			CloseChannelFunc: func(ctx context.Context, channelID string) error {
// 				panic("mock out the CloseChannel method")
// 			},
// 			PeerChannelAPITokensCreateFunc: func(ctx context.Context, reqs ...*payd.PeerChannelAPITokenCreateArgs) ([]*spvchannels.TokenCreateReply, error) {
// 				panic("mock out the PeerChannelAPITokensCreate method")
// 			},
// 			PeerChannelCreateFunc: func(ctx context.Context, req spvchannels.ChannelCreateRequest) (*payd.PeerChannel, error) {
// 				panic("mock out the PeerChannelCreate method")
// 			},
// 			PeerChannelsMessageFunc: func(ctx context.Context, args *payd.PeerChannelMessageArgs) (spvchannels.MessagesReply, error) {
// 				panic("mock out the PeerChannelsMessage method")
// 			},
// 		}
//
// 		// use mockedPeerChannelsService in code that requires payd.PeerChannelsService
// 		// and then make assertions.
//
// 	}
type PeerChannelsServiceMock struct {
	// ActiveProofChannelsFunc mocks the ActiveProofChannels method.
	ActiveProofChannelsFunc func(ctx context.Context) ([]payd.PeerChannel, error)

	// CloseChannelFunc mocks the CloseChannel method.
	CloseChannelFunc func(ctx context.Context, channelID string) error

	// PeerChannelAPITokensCreateFunc mocks the PeerChannelAPITokensCreate method.
	PeerChannelAPITokensCreateFunc func(ctx context.Context, reqs ...*payd.PeerChannelAPITokenCreateArgs) ([]*spvchannels.TokenCreateReply, error)

	// PeerChannelCreateFunc mocks the PeerChannelCreate method.
	PeerChannelCreateFunc func(ctx context.Context, req spvchannels.ChannelCreateRequest) (*payd.PeerChannel, error)

	// PeerChannelsMessageFunc mocks the PeerChannelsMessage method.
	PeerChannelsMessageFunc func(ctx context.Context, args *payd.PeerChannelMessageArgs) (spvchannels.MessagesReply, error)

	// calls tracks calls to the methods.
	calls struct {
		// ActiveProofChannels holds details about calls to the ActiveProofChannels method.
		ActiveProofChannels []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CloseChannel holds details about calls to the CloseChannel method.
		CloseChannel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// PeerChannelAPITokensCreate holds details about calls to the PeerChannelAPITokensCreate method.
		PeerChannelAPITokensCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Reqs is the reqs argument value.
			Reqs []*payd.PeerChannelAPITokenCreateArgs
		}
		// PeerChannelCreate holds details about calls to the PeerChannelCreate method.
		PeerChannelCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req spvchannels.ChannelCreateRequest
		}
		// PeerChannelsMessage holds details about calls to the PeerChannelsMessage method.
		PeerChannelsMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args *payd.PeerChannelMessageArgs
		}
	}
	lockActiveProofChannels        sync.RWMutex
	lockCloseChannel               sync.RWMutex
	lockPeerChannelAPITokensCreate sync.RWMutex
	lockPeerChannelCreate          sync.RWMutex
	lockPeerChannelsMessage        sync.RWMutex
}

// ActiveProofChannels calls ActiveProofChannelsFunc.
func (mock *PeerChannelsServiceMock) ActiveProofChannels(ctx context.Context) ([]payd.PeerChannel, error) {
	if mock.ActiveProofChannelsFunc == nil {
		panic("PeerChannelsServiceMock.ActiveProofChannelsFunc: method is nil but PeerChannelsService.ActiveProofChannels was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockActiveProofChannels.Lock()
	mock.calls.ActiveProofChannels = append(mock.calls.ActiveProofChannels, callInfo)
	mock.lockActiveProofChannels.Unlock()
	return mock.ActiveProofChannelsFunc(ctx)
}

// ActiveProofChannelsCalls gets all the calls that were made to ActiveProofChannels.
// Check the length with:
//     len(mockedPeerChannelsService.ActiveProofChannelsCalls())
func (mock *PeerChannelsServiceMock) ActiveProofChannelsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockActiveProofChannels.RLock()
	calls = mock.calls.ActiveProofChannels
	mock.lockActiveProofChannels.RUnlock()
	return calls
}

// CloseChannel calls CloseChannelFunc.
func (mock *PeerChannelsServiceMock) CloseChannel(ctx context.Context, channelID string) error {
	if mock.CloseChannelFunc == nil {
		panic("PeerChannelsServiceMock.CloseChannelFunc: method is nil but PeerChannelsService.CloseChannel was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
	}
	mock.lockCloseChannel.Lock()
	mock.calls.CloseChannel = append(mock.calls.CloseChannel, callInfo)
	mock.lockCloseChannel.Unlock()
	return mock.CloseChannelFunc(ctx, channelID)
}

// CloseChannelCalls gets all the calls that were made to CloseChannel.
// Check the length with:
//     len(mockedPeerChannelsService.CloseChannelCalls())
func (mock *PeerChannelsServiceMock) CloseChannelCalls() []struct {
	Ctx       context.Context
	ChannelID string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
	}
	mock.lockCloseChannel.RLock()
	calls = mock.calls.CloseChannel
	mock.lockCloseChannel.RUnlock()
	return calls
}

// PeerChannelAPITokensCreate calls PeerChannelAPITokensCreateFunc.
func (mock *PeerChannelsServiceMock) PeerChannelAPITokensCreate(ctx context.Context, reqs ...*payd.PeerChannelAPITokenCreateArgs) ([]*spvchannels.TokenCreateReply, error) {
	if mock.PeerChannelAPITokensCreateFunc == nil {
		panic("PeerChannelsServiceMock.PeerChannelAPITokensCreateFunc: method is nil but PeerChannelsService.PeerChannelAPITokensCreate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Reqs []*payd.PeerChannelAPITokenCreateArgs
	}{
		Ctx:  ctx,
		Reqs: reqs,
	}
	mock.lockPeerChannelAPITokensCreate.Lock()
	mock.calls.PeerChannelAPITokensCreate = append(mock.calls.PeerChannelAPITokensCreate, callInfo)
	mock.lockPeerChannelAPITokensCreate.Unlock()
	return mock.PeerChannelAPITokensCreateFunc(ctx, reqs...)
}

// PeerChannelAPITokensCreateCalls gets all the calls that were made to PeerChannelAPITokensCreate.
// Check the length with:
//     len(mockedPeerChannelsService.PeerChannelAPITokensCreateCalls())
func (mock *PeerChannelsServiceMock) PeerChannelAPITokensCreateCalls() []struct {
	Ctx  context.Context
	Reqs []*payd.PeerChannelAPITokenCreateArgs
} {
	var calls []struct {
		Ctx  context.Context
		Reqs []*payd.PeerChannelAPITokenCreateArgs
	}
	mock.lockPeerChannelAPITokensCreate.RLock()
	calls = mock.calls.PeerChannelAPITokensCreate
	mock.lockPeerChannelAPITokensCreate.RUnlock()
	return calls
}

// PeerChannelCreate calls PeerChannelCreateFunc.
func (mock *PeerChannelsServiceMock) PeerChannelCreate(ctx context.Context, req spvchannels.ChannelCreateRequest) (*payd.PeerChannel, error) {
	if mock.PeerChannelCreateFunc == nil {
		panic("PeerChannelsServiceMock.PeerChannelCreateFunc: method is nil but PeerChannelsService.PeerChannelCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req spvchannels.ChannelCreateRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockPeerChannelCreate.Lock()
	mock.calls.PeerChannelCreate = append(mock.calls.PeerChannelCreate, callInfo)
	mock.lockPeerChannelCreate.Unlock()
	return mock.PeerChannelCreateFunc(ctx, req)
}

// PeerChannelCreateCalls gets all the calls that were made to PeerChannelCreate.
// Check the length with:
//     len(mockedPeerChannelsService.PeerChannelCreateCalls())
func (mock *PeerChannelsServiceMock) PeerChannelCreateCalls() []struct {
	Ctx context.Context
	Req spvchannels.ChannelCreateRequest
} {
	var calls []struct {
		Ctx context.Context
		Req spvchannels.ChannelCreateRequest
	}
	mock.lockPeerChannelCreate.RLock()
	calls = mock.calls.PeerChannelCreate
	mock.lockPeerChannelCreate.RUnlock()
	return calls
}

// PeerChannelsMessage calls PeerChannelsMessageFunc.
func (mock *PeerChannelsServiceMock) PeerChannelsMessage(ctx context.Context, args *payd.PeerChannelMessageArgs) (spvchannels.MessagesReply, error) {
	if mock.PeerChannelsMessageFunc == nil {
		panic("PeerChannelsServiceMock.PeerChannelsMessageFunc: method is nil but PeerChannelsService.PeerChannelsMessage was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args *payd.PeerChannelMessageArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockPeerChannelsMessage.Lock()
	mock.calls.PeerChannelsMessage = append(mock.calls.PeerChannelsMessage, callInfo)
	mock.lockPeerChannelsMessage.Unlock()
	return mock.PeerChannelsMessageFunc(ctx, args)
}

// PeerChannelsMessageCalls gets all the calls that were made to PeerChannelsMessage.
// Check the length with:
//     len(mockedPeerChannelsService.PeerChannelsMessageCalls())
func (mock *PeerChannelsServiceMock) PeerChannelsMessageCalls() []struct {
	Ctx  context.Context
	Args *payd.PeerChannelMessageArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args *payd.PeerChannelMessageArgs
	}
	mock.lockPeerChannelsMessage.RLock()
	calls = mock.calls.PeerChannelsMessage
	mock.lockPeerChannelsMessage.RUnlock()
	return calls
}
