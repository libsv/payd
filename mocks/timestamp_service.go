// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/libsv/payd"
	"sync"
	"time"
)

// Ensure, that TimestampServiceMock does implement payd.TimestampService.
// If this is not the case, regenerate this file with moq.
var _ payd.TimestampService = &TimestampServiceMock{}

// TimestampServiceMock is a mock implementation of payd.TimestampService.
//
// 	func TestSomethingThatUsesTimestampService(t *testing.T) {
//
// 		// make and configure a mocked payd.TimestampService
// 		mockedTimestampService := &TimestampServiceMock{
// 			NanosecondFunc: func() int {
// 				panic("mock out the Nanosecond method")
// 			},
// 			NowUTCFunc: func() time.Time {
// 				panic("mock out the NowUTC method")
// 			},
// 		}
//
// 		// use mockedTimestampService in code that requires payd.TimestampService
// 		// and then make assertions.
//
// 	}
type TimestampServiceMock struct {
	// NanosecondFunc mocks the Nanosecond method.
	NanosecondFunc func() int

	// NowUTCFunc mocks the NowUTC method.
	NowUTCFunc func() time.Time

	// calls tracks calls to the methods.
	calls struct {
		// Nanosecond holds details about calls to the Nanosecond method.
		Nanosecond []struct {
		}
		// NowUTC holds details about calls to the NowUTC method.
		NowUTC []struct {
		}
	}
	lockNanosecond sync.RWMutex
	lockNowUTC     sync.RWMutex
}

// Nanosecond calls NanosecondFunc.
func (mock *TimestampServiceMock) Nanosecond() int {
	if mock.NanosecondFunc == nil {
		panic("TimestampServiceMock.NanosecondFunc: method is nil but TimestampService.Nanosecond was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNanosecond.Lock()
	mock.calls.Nanosecond = append(mock.calls.Nanosecond, callInfo)
	mock.lockNanosecond.Unlock()
	return mock.NanosecondFunc()
}

// NanosecondCalls gets all the calls that were made to Nanosecond.
// Check the length with:
//     len(mockedTimestampService.NanosecondCalls())
func (mock *TimestampServiceMock) NanosecondCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNanosecond.RLock()
	calls = mock.calls.Nanosecond
	mock.lockNanosecond.RUnlock()
	return calls
}

// NowUTC calls NowUTCFunc.
func (mock *TimestampServiceMock) NowUTC() time.Time {
	if mock.NowUTCFunc == nil {
		panic("TimestampServiceMock.NowUTCFunc: method is nil but TimestampService.NowUTC was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNowUTC.Lock()
	mock.calls.NowUTC = append(mock.calls.NowUTC, callInfo)
	mock.lockNowUTC.Unlock()
	return mock.NowUTCFunc()
}

// NowUTCCalls gets all the calls that were made to NowUTC.
// Check the length with:
//     len(mockedTimestampService.NowUTCCalls())
func (mock *TimestampServiceMock) NowUTCCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNowUTC.RLock()
	calls = mock.calls.NowUTC
	mock.lockNowUTC.RUnlock()
	return calls
}
