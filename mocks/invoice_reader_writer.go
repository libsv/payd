// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/libsv/payd"
)

// Ensure, that InvoiceReaderWriterMock does implement payd.InvoiceReaderWriter.
// If this is not the case, regenerate this file with moq.
var _ payd.InvoiceReaderWriter = &InvoiceReaderWriterMock{}

// InvoiceReaderWriterMock is a mock implementation of payd.InvoiceReaderWriter.
//
// 	func TestSomethingThatUsesInvoiceReaderWriter(t *testing.T) {
//
// 		// make and configure a mocked payd.InvoiceReaderWriter
// 		mockedInvoiceReaderWriter := &InvoiceReaderWriterMock{
// 			InvoiceFunc: func(ctx context.Context, args payd.InvoiceArgs) (*payd.Invoice, error) {
// 				panic("mock out the Invoice method")
// 			},
// 			InvoiceCreateFunc: func(ctx context.Context, req payd.InvoiceCreate) (*payd.Invoice, error) {
// 				panic("mock out the InvoiceCreate method")
// 			},
// 			InvoiceDeleteFunc: func(ctx context.Context, args payd.InvoiceArgs) error {
// 				panic("mock out the InvoiceDelete method")
// 			},
// 			InvoiceUpdateFunc: func(ctx context.Context, args payd.InvoiceUpdateArgs, req payd.InvoiceUpdatePaid) (*payd.Invoice, error) {
// 				panic("mock out the InvoiceUpdate method")
// 			},
// 			InvoicesFunc: func(ctx context.Context) ([]payd.Invoice, error) {
// 				panic("mock out the Invoices method")
// 			},
// 			InvoicesPendingFunc: func(ctx context.Context) ([]payd.Invoice, error) {
// 				panic("mock out the InvoicesPending method")
// 			},
// 		}
//
// 		// use mockedInvoiceReaderWriter in code that requires payd.InvoiceReaderWriter
// 		// and then make assertions.
//
// 	}
type InvoiceReaderWriterMock struct {
	// InvoiceFunc mocks the Invoice method.
	InvoiceFunc func(ctx context.Context, args payd.InvoiceArgs) (*payd.Invoice, error)

	// InvoiceCreateFunc mocks the InvoiceCreate method.
	InvoiceCreateFunc func(ctx context.Context, req payd.InvoiceCreate) (*payd.Invoice, error)

	// InvoiceDeleteFunc mocks the InvoiceDelete method.
	InvoiceDeleteFunc func(ctx context.Context, args payd.InvoiceArgs) error

	// InvoiceUpdateFunc mocks the InvoiceUpdate method.
	InvoiceUpdateFunc func(ctx context.Context, args payd.InvoiceUpdateArgs, req payd.InvoiceUpdatePaid) (*payd.Invoice, error)

	// InvoicesFunc mocks the Invoices method.
	InvoicesFunc func(ctx context.Context) ([]payd.Invoice, error)

	// InvoicesPendingFunc mocks the InvoicesPending method.
	InvoicesPendingFunc func(ctx context.Context) ([]payd.Invoice, error)

	// calls tracks calls to the methods.
	calls struct {
		// Invoice holds details about calls to the Invoice method.
		Invoice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args payd.InvoiceArgs
		}
		// InvoiceCreate holds details about calls to the InvoiceCreate method.
		InvoiceCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req payd.InvoiceCreate
		}
		// InvoiceDelete holds details about calls to the InvoiceDelete method.
		InvoiceDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args payd.InvoiceArgs
		}
		// InvoiceUpdate holds details about calls to the InvoiceUpdate method.
		InvoiceUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args payd.InvoiceUpdateArgs
			// Req is the req argument value.
			Req payd.InvoiceUpdatePaid
		}
		// Invoices holds details about calls to the Invoices method.
		Invoices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// InvoicesPending holds details about calls to the InvoicesPending method.
		InvoicesPending []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockInvoice         sync.RWMutex
	lockInvoiceCreate   sync.RWMutex
	lockInvoiceDelete   sync.RWMutex
	lockInvoiceUpdate   sync.RWMutex
	lockInvoices        sync.RWMutex
	lockInvoicesPending sync.RWMutex
}

// Invoice calls InvoiceFunc.
func (mock *InvoiceReaderWriterMock) Invoice(ctx context.Context, args payd.InvoiceArgs) (*payd.Invoice, error) {
	if mock.InvoiceFunc == nil {
		panic("InvoiceReaderWriterMock.InvoiceFunc: method is nil but InvoiceReaderWriter.Invoice was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args payd.InvoiceArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockInvoice.Lock()
	mock.calls.Invoice = append(mock.calls.Invoice, callInfo)
	mock.lockInvoice.Unlock()
	return mock.InvoiceFunc(ctx, args)
}

// InvoiceCalls gets all the calls that were made to Invoice.
// Check the length with:
//     len(mockedInvoiceReaderWriter.InvoiceCalls())
func (mock *InvoiceReaderWriterMock) InvoiceCalls() []struct {
	Ctx  context.Context
	Args payd.InvoiceArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args payd.InvoiceArgs
	}
	mock.lockInvoice.RLock()
	calls = mock.calls.Invoice
	mock.lockInvoice.RUnlock()
	return calls
}

// InvoiceCreate calls InvoiceCreateFunc.
func (mock *InvoiceReaderWriterMock) InvoiceCreate(ctx context.Context, req payd.InvoiceCreate) (*payd.Invoice, error) {
	if mock.InvoiceCreateFunc == nil {
		panic("InvoiceReaderWriterMock.InvoiceCreateFunc: method is nil but InvoiceReaderWriter.InvoiceCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req payd.InvoiceCreate
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockInvoiceCreate.Lock()
	mock.calls.InvoiceCreate = append(mock.calls.InvoiceCreate, callInfo)
	mock.lockInvoiceCreate.Unlock()
	return mock.InvoiceCreateFunc(ctx, req)
}

// InvoiceCreateCalls gets all the calls that were made to InvoiceCreate.
// Check the length with:
//     len(mockedInvoiceReaderWriter.InvoiceCreateCalls())
func (mock *InvoiceReaderWriterMock) InvoiceCreateCalls() []struct {
	Ctx context.Context
	Req payd.InvoiceCreate
} {
	var calls []struct {
		Ctx context.Context
		Req payd.InvoiceCreate
	}
	mock.lockInvoiceCreate.RLock()
	calls = mock.calls.InvoiceCreate
	mock.lockInvoiceCreate.RUnlock()
	return calls
}

// InvoiceDelete calls InvoiceDeleteFunc.
func (mock *InvoiceReaderWriterMock) InvoiceDelete(ctx context.Context, args payd.InvoiceArgs) error {
	if mock.InvoiceDeleteFunc == nil {
		panic("InvoiceReaderWriterMock.InvoiceDeleteFunc: method is nil but InvoiceReaderWriter.InvoiceDelete was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args payd.InvoiceArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockInvoiceDelete.Lock()
	mock.calls.InvoiceDelete = append(mock.calls.InvoiceDelete, callInfo)
	mock.lockInvoiceDelete.Unlock()
	return mock.InvoiceDeleteFunc(ctx, args)
}

// InvoiceDeleteCalls gets all the calls that were made to InvoiceDelete.
// Check the length with:
//     len(mockedInvoiceReaderWriter.InvoiceDeleteCalls())
func (mock *InvoiceReaderWriterMock) InvoiceDeleteCalls() []struct {
	Ctx  context.Context
	Args payd.InvoiceArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args payd.InvoiceArgs
	}
	mock.lockInvoiceDelete.RLock()
	calls = mock.calls.InvoiceDelete
	mock.lockInvoiceDelete.RUnlock()
	return calls
}

// InvoiceUpdate calls InvoiceUpdateFunc.
func (mock *InvoiceReaderWriterMock) InvoiceUpdate(ctx context.Context, args payd.InvoiceUpdateArgs, req payd.InvoiceUpdatePaid) (*payd.Invoice, error) {
	if mock.InvoiceUpdateFunc == nil {
		panic("InvoiceReaderWriterMock.InvoiceUpdateFunc: method is nil but InvoiceReaderWriter.InvoiceUpdate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args payd.InvoiceUpdateArgs
		Req  payd.InvoiceUpdatePaid
	}{
		Ctx:  ctx,
		Args: args,
		Req:  req,
	}
	mock.lockInvoiceUpdate.Lock()
	mock.calls.InvoiceUpdate = append(mock.calls.InvoiceUpdate, callInfo)
	mock.lockInvoiceUpdate.Unlock()
	return mock.InvoiceUpdateFunc(ctx, args, req)
}

// InvoiceUpdateCalls gets all the calls that were made to InvoiceUpdate.
// Check the length with:
//     len(mockedInvoiceReaderWriter.InvoiceUpdateCalls())
func (mock *InvoiceReaderWriterMock) InvoiceUpdateCalls() []struct {
	Ctx  context.Context
	Args payd.InvoiceUpdateArgs
	Req  payd.InvoiceUpdatePaid
} {
	var calls []struct {
		Ctx  context.Context
		Args payd.InvoiceUpdateArgs
		Req  payd.InvoiceUpdatePaid
	}
	mock.lockInvoiceUpdate.RLock()
	calls = mock.calls.InvoiceUpdate
	mock.lockInvoiceUpdate.RUnlock()
	return calls
}

// Invoices calls InvoicesFunc.
func (mock *InvoiceReaderWriterMock) Invoices(ctx context.Context) ([]payd.Invoice, error) {
	if mock.InvoicesFunc == nil {
		panic("InvoiceReaderWriterMock.InvoicesFunc: method is nil but InvoiceReaderWriter.Invoices was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockInvoices.Lock()
	mock.calls.Invoices = append(mock.calls.Invoices, callInfo)
	mock.lockInvoices.Unlock()
	return mock.InvoicesFunc(ctx)
}

// InvoicesCalls gets all the calls that were made to Invoices.
// Check the length with:
//     len(mockedInvoiceReaderWriter.InvoicesCalls())
func (mock *InvoiceReaderWriterMock) InvoicesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockInvoices.RLock()
	calls = mock.calls.Invoices
	mock.lockInvoices.RUnlock()
	return calls
}

// InvoicesPending calls InvoicesPendingFunc.
func (mock *InvoiceReaderWriterMock) InvoicesPending(ctx context.Context) ([]payd.Invoice, error) {
	if mock.InvoicesPendingFunc == nil {
		panic("InvoiceReaderWriterMock.InvoicesPendingFunc: method is nil but InvoiceReaderWriter.InvoicesPending was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockInvoicesPending.Lock()
	mock.calls.InvoicesPending = append(mock.calls.InvoicesPending, callInfo)
	mock.lockInvoicesPending.Unlock()
	return mock.InvoicesPendingFunc(ctx)
}

// InvoicesPendingCalls gets all the calls that were made to InvoicesPending.
// Check the length with:
//     len(mockedInvoiceReaderWriter.InvoicesPendingCalls())
func (mock *InvoiceReaderWriterMock) InvoicesPendingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockInvoicesPending.RLock()
	calls = mock.calls.InvoicesPending
	mock.lockInvoicesPending.RUnlock()
	return calls
}
